[![Start tests](https://github.com/ApathyInMyHeart/testirovanie_laba2/actions/workflows/actions.yml/badge.svg)](https://github.com/ApathyInMyHeart/testirovanie_laba2/actions/workflows/actions.yml)
[![Coverage Status](https://coveralls.io/repos/github/ApathyInMyHeart/testirovanie_laba2/badge.svg?branch=master)](https://coveralls.io/github/ApathyInMyHeart/testirovanie_laba2?branch=master)
[![Quality Gate Status](https://sonarcloud.io/api/project_badges/measure?project=ApathyInMyHeart_testirovanie_laba2&metric=alert_status)](https://sonarcloud.io/summary/new_code?id=ApathyInMyHeart_testirovanie_laba2)
[![Bugs](https://sonarcloud.io/api/project_badges/measure?project=ApathyInMyHeart_testirovanie_laba2&metric=bugs)](https://sonarcloud.io/summary/new_code?id=ApathyInMyHeart_testirovanie_laba2)
[![Code Smells](https://sonarcloud.io/api/project_badges/measure?project=ApathyInMyHeart_testirovanie_laba2&metric=code_smells)](https://sonarcloud.io/summary/new_code?id=ApathyInMyHeart_testirovanie_laba2)
[![Duplicated Lines (%)](https://sonarcloud.io/api/project_badges/measure?project=ApathyInMyHeart_testirovanie_laba2&metric=duplicated_lines_density)](https://sonarcloud.io/summary/new_code?id=ApathyInMyHeart_testirovanie_laba2)
[![Lines of Code](https://sonarcloud.io/api/project_badges/measure?project=ApathyInMyHeart_testirovanie_laba2&metric=ncloc)](https://sonarcloud.io/summary/new_code?id=ApathyInMyHeart_testirovanie_laba2)
[![Reliability Rating](https://sonarcloud.io/api/project_badges/measure?project=ApathyInMyHeart_testirovanie_laba2&metric=reliability_rating)](https://sonarcloud.io/summary/new_code?id=ApathyInMyHeart_testirovanie_laba2)
[![Security Rating](https://sonarcloud.io/api/project_badges/measure?project=ApathyInMyHeart_testirovanie_laba2&metric=security_rating)](https://sonarcloud.io/summary/new_code?id=ApathyInMyHeart_testirovanie_laba2)
[![Technical Debt](https://sonarcloud.io/api/project_badges/measure?project=ApathyInMyHeart_testirovanie_laba2&metric=sqale_index)](https://sonarcloud.io/summary/new_code?id=ApathyInMyHeart_testirovanie_laba2)
[![Maintainability Rating](https://sonarcloud.io/api/project_badges/measure?project=ApathyInMyHeart_testirovanie_laba2&metric=sqale_rating)](https://sonarcloud.io/summary/new_code?id=ApathyInMyHeart_testirovanie_laba2)
[![Vulnerabilities](https://sonarcloud.io/api/project_badges/measure?project=ApathyInMyHeart_testirovanie_laba2&metric=vulnerabilities)](https://sonarcloud.io/summary/new_code?id=ApathyInMyHeart_testirovanie_laba2)
[![Quality gate](https://sonarcloud.io/api/project_badges/quality_gate?project=ApathyInMyHeart_testirovanie_laba2)](https://sonarcloud.io/summary/new_code?id=ApathyInMyHeart_testirovanie_laba2)
[![SonarQube Cloud](https://sonarcloud.io/images/project_badges/sonarcloud-light.svg)](https://sonarcloud.io/summary/new_code?id=ApathyInMyHeart_testirovanie_laba2)
# testing2
Проект для Лабораторной работы № 2 в рамках курса Тестирование ПО

## Класс Vector2D:

Представляет собой двухмерный вектор с координатами x и y.

### Поля:

* `x` - координата X (тип: `float`)
* `y` - координата Y (тип: `float`)

### Методы:

* `__init__(self, x, y)`: Конструктор класса.  Инициализирует объект `Vector2D` с заданными координатами.

* `__add__(self, other)`: Оператор сложения. Возвращает новый вектор, являющийся суммой текущего вектора и вектора `other`.

* `__sub__(self, other)`: Оператор вычитания. Возвращает новый вектор, являющийся разностью текущего вектора и вектора `other`.

* `__mul__(self, scalar)`: Оператор умножения. Возвращает новый вектор, полученный путем умножения текущего вектора на скаляр.

* `length(self)`: Вычисляет и возвращает длину вектора.

* `normalize(self)`: Нормализует вектор (делает его длину равной 1). Возвращает новый вектор, являющийся нормализованным вариантом текущего вектора.

## Класс Vector3D:

Представляет собой трехмерный вектор с координатами x, y и z.

### Поля:

* `x` - координата X (тип: `float`)
* `y` - координата Y (тип: `float`)
* `z` - координата Z (тип: `float`)

### Методы:

* `__init__(self, x, y, z)`: Конструктор класса.  Инициализирует объект `Vector3D` с заданными координатами.

* `__add__(self, other)`: Оператор сложения. Возвращает новый вектор, являющийся суммой текущего вектора и вектора `other`.

* `__sub__(self, other)`: Оператор вычитания. Возвращает новый вектор, являющийся разностью текущего вектора и вектора `other`.

* `__mul__(self, scalar)`: Оператор умножения. Возвращает новый вектор, полученный путем умножения текущего вектора на скаляр.

* `length(self)`: Вычисляет и возвращает длину вектора.

* `normalize(self)`: Нормализует вектор (делает его длину равной 1). Возвращает новый вектор, являющийся нормализованным вариантом текущего вектора.

* `dot_product(self, other)`: Вычисляет и возвращает скалярное произведение текущего вектора и вектора `other`.

* `cross_product(self, other)`: Вычисляет и возвращает векторное произведение текущего вектора и вектора `other`.

* `scalar_triple_product(self, other1, other2)`: Вычисляет и возвращает смешанное произведение векторов `self`, `other1`, и `other2`.

## Класс Line2D:

Представляет собой прямую линию в двумерном пространстве, определяемую двумя точками.

### Поля:

* `point1`: Первая точка, определяющая линию (объект `Vector2D`).
* `point2`: Вторая точка, определяющая линию (объект `Vector2D`).

### Методы:

* `__init__(self, point1: Vector2D, point2: Vector2D)`: Конструктор класса.  Инициализирует объект `Line2D` с заданными точками.

* `distance_to_point(self, point: Vector2D)`: Вычисляет расстояние от заданной точки до линии.

* `is_parallel(self, other)`: Проверяет, параллельна ли текущая линия другой линии `other`.

* `intersection(self, other)`: Находит точку пересечения текущей линии с другой линией `other`. Возвращает объект `Vector2D`, представляющий точку пересечения, или `None`, если линии параллельны или совпадают.

* `point_on_line(self, point: Vector2D)`: Проверяет, лежит ли заданная точка на линии.

* `angle(self, other)`: Вычисляет угол между текущей линией и другой линией `other`.

## Класс Plane3D:

Представляет собой плоскость в трехмерном пространстве, определяемую точкой и нормальным вектором.

### Поля:

* `point`: Точка, лежащая на плоскости (объект `Vector3D`).
* `normal`: Нормальный вектор плоскости (объект `Vector3D`).

### Методы:

* `__init__(self, point: Vector3D, normal: Vector3D)`: Конструктор класса.  Инициализирует объект `Plane3D` с заданной точкой и нормальным вектором.

* `distance_to_point(self, point: Vector3D)`: Вычисляет расстояние от заданной точки до плоскости.

* `is_parallel(self, other)`: Проверяет, параллельна ли текущая плоскость другой плоскости `other`.

* `is_perpendicular(self, other)`: Проверяет, перпендикулярна ли текущая плоскость другой плоскости `other`.

* `intersection_with_line(self, point1: Vector3D, point2: Vector3D)`: Находит точку пересечения текущей плоскости с прямой, заданной двумя точками `point1` и `point2`. Возвращает объект `Vector3D`, представляющий точку пересечения, или `None`, если прямая параллельна плоскости или лежит на ней.

* `point_on_plane(self, point: Vector3D)`: Проверяет, лежит ли заданная точка на плоскости.

# План тестирования

## Модульное тестирование
### Класс Vector2D

#### `test_init`:
* **Описание:** Проверяет, что конструктор класса `Vector2D` правильно инициализирует координаты вектора.
* **Тип теста:** Позитивный.
* **Входные данные:** Координаты `x = 1`, `y = 2`.
* **Ожидаемый результат:** Создается объект `Vector2D` с координатами `x = 1` и `y = 2`.

#### `test_add`:
* **Описание:** Проверяет корректность работы операции сложения векторов.
* **Тип теста:** Позитивный.
* **Входные данные:** Два вектора `v1 = (1, 2)` и `v2 = (3, 4)`.
* **Ожидаемый результат:** Результат сложения `v1 + v2` должен быть `(4, 6)`.

#### `test_sub`:
* **Описание:** Проверяет корректность работы операции вычитания векторов.
* **Тип теста:** Позитивный.
* **Входные данные:** Два вектора `v1 = (1, 2)` и `v2 = (3, 4)`.
* **Ожидаемый результат:** Результат вычитания `v1 - v2` должен быть `(-2, -2)`.

#### `test_mul`:
* **Описание:** Проверяет корректность работы операции умножения вектора на скаляр.
* **Тип теста:** Позитивный.
* **Входные данные:** Вектор `v = (1, 2)` и скаляр `scalar = 3`.
* **Ожидаемый результат:** Результат умножения `v * scalar` должен быть `(3, 6)`.

#### `test_length`:
* **Описание:** Проверяет корректность вычисления длины вектора.
* **Тип теста:** Позитивный.
* **Входные данные:** Вектор `v = (3, 4)`.
* **Ожидаемый результат:** Длина вектора `v` должна быть `5` (с учетом возможной погрешности).

#### `test_normalize`:
* **Описание:** Проверяет корректность работы операции нормализации вектора.
* **Тип теста:** Позитивный.
* **Входные данные:** Вектор `v = (3, 4)`.
* **Ожидаемый результат:** Длина нормализованного вектора должна быть `1`, а координаты должны быть пропорциональны исходным координатам `v`.

#### `test_zero_vector`:
* **Описание:** Проверяет корректность работы операции нормализации нулевого вектора.
* **Тип теста:** Позитивный.
* **Входные данные:** Нулевой вектор `v = (0, 0)`.
* **Ожидаемый результат:** Нормализация нулевого вектора должна вернуть сам нулевой вектор.

### Класс Vector3D

#### `test_init`:
* **Описание:** Проверяет, что конструктор класса `Vector3D` правильно инициализирует координаты вектора.
* **Тип теста:** Позитивный.
* **Входные данные:** Координаты `x = 1`, `y = 2`, `z = 3`.
* **Ожидаемый результат:** Создается объект `Vector3D` с координатами `x = 1`, `y = 2`, `z = 3`.

#### `test_add`:
* **Описание:** Проверяет корректность работы операции сложения векторов.
* **Тип теста:** Позитивный.
* **Входные данные:** Два вектора `v1 = (1, 2, 3)` и `v2 = (4, 5, 6)`.
* **Ожидаемый результат:** Результат сложения `v1 + v2` должен быть `(5, 7, 9)`.

#### `test_sub`:
* **Описание:** Проверяет корректность работы операции вычитания векторов.
* **Тип теста:** Позитивный.
* **Входные данные:** Два вектора `v1 = (1, 2, 3)` и `v2 = (4, 5, 6)`.
* **Ожидаемый результат:** Результат вычитания `v1 - v2` должен быть `(-3, -3, -3)`.

#### `test_mul`:
* **Описание:** Проверяет корректность работы операции умножения вектора на скаляр.
* **Тип теста:** Позитивный.
* **Входные данные:** Вектор `v = (1, 2, 3)` и скаляр `scalar = 2`.
* **Ожидаемый результат:** Результат умножения `v * scalar` должен быть `(2, 4, 6)`.

#### `test_length`:
* **Описание:** Проверяет корректность вычисления длины вектора.
* **Тип теста:** Позитивный.
* **Входные данные:** Вектор `v = (3, 4, 5)`.
* **Ожидаемый результат:** Длина вектора `v` должна быть `7.07106781` (с учетом возможной погрешности).

#### `test_normalize`:
* **Описание:** Проверяет корректность работы операции нормализации вектора.
* **Тип теста:** Позитивный.
* **Входные данные:** Вектор `v = (3, 4, 5)`.
* **Ожидаемый результат:** Длина нормализованного вектора должна быть `1`, а координаты должны быть пропорциональны исходным координатам `v`.

#### `test_dot_product`:
* **Описание:** Проверяет корректность работы скалярного произведения векторов.
* **Тип теста:** Позитивный.
* **Входные данные:** Векторы `v1 = (1, 2, 3)` и `v2 = (4, 5, 6)`.
* **Ожидаемый результат:** Скалярное произведение `v1` и `v2` должно быть `32`.

#### `test_cross_product`:
* **Описание:** Проверяет корректность работы векторного произведения векторов.
* **Тип теста:** Позитивный.
* **Входные данные:** Векторы `v1 = (1, 2, 3)` и `v2 = (4, 5, 6)`.
* **Ожидаемый результат:** Векторное произведение `v1` и `v2` должно быть `(-3, 6, -3)`.

#### `test_scalar_triple_product`:
* **Описание:** Проверяет корректность работы смешанного произведения векторов.
* **Тип теста:** Позитивный.
* **Входные данные:** Векторы `v1 = (1, 2, 3)`, `v2 = (4, 5, 6)`, `v3 = (7, 8, 9)`.
* **Ожидаемый результат:** Смешанное произведение `v1`, `v2` и `v3` должно быть `0`, так как векторы компланарны.

### Класс Line2D

#### `test_init`:
* **Описание:** Проверяет, что конструктор класса `Line2D` правильно инициализирует точки, определяющие линию.
* **Тип теста:** Позитивный.
* **Входные данные:** Точки `point1 = (1, 2)` и `point2 = (3, 4)`.
* **Ожидаемый результат:** Создается объект `Line2D` с заданными точками.

#### `test_distance_to_point`:
* **Описание:** Проверяет корректность вычисления расстояния от точки до линии.
* **Тип теста:** Позитивный.
* **Входные данные:** Линия, заданная точками (0, 0) и (1, 1), точка (1, 0).
* **Ожидаемый результат:** Расстояние от точки до линии должно быть `0.70710678` (с учетом возможной погрешности).

#### `test_is_parallel`:
* **Описание:** Проверяет корректность работы метода `is_parallel` для определения параллельности двух линий.
* **Тип теста:** Позитивный и негативный.
* **Входные данные:** Две параллельные линии и две непараллельные линии.
* **Ожидаемый результат:** Метод `is_parallel` должен вернуть `True` для параллельных линий и `False` для непараллельных линий.

#### `test_intersection`:
* **Описание:** Проверяет корректность работы метода `intersection` для нахождения точки пересечения двух линий.
* **Тип теста:** Позитивный и негативный.
* **Входные данные:** Две линии, которые пересекаются, две линии, которые параллельны, и две линии, которые совпадают.
* **Ожидаемый результат:** Метод `intersection` должен вернуть точку пересечения для пересекающихся линий, `None` для параллельных линий и `None` для совпадающих линий.

#### `test_point_on_line`:
* **Описание:** Проверяет корректность работы метода `point_on_line` для определения, лежит ли точка на линии.
* **Тип теста:** Позитивный и негативный.
* **Входные данные:** Линия, заданная точками (0, 0) и (1, 1), точки (0.5, 0.5), (1.5, 1.5) и (1, 0).
* **Ожидаемый результат:** Метод `point_on_line` должен вернуть `True` для точек (0.5, 0.5) и (1.5, 1.5) и `False` для точки (1, 0).

#### `test_angle`:
* **Описание:** Проверяет корректность работы метода `angle` для вычисления угла между двумя линиями.
* **Тип теста:** Позитивный.
* **Входные данные:** Две линии: первая проходит через точки (0, 0) и (1, 0), вторая - через точки (0, 0) и (1, 1).
* **Ожидаемый результат:** Угол между линиями должен быть `pi/4` (45 градусов).

### Класс Plane3D

#### `test_init`:
* **Описание:** Проверяет, что конструктор класса `Plane3D` правильно инициализирует точку и нормальный вектор плоскости.
* **Тип теста:** Позитивный.
* **Входные данные:** Точка `point = (1, 2, 3)` и нормальный вектор `normal = (0, 0, 1)`.
* **Ожидаемый результат:** Создается объект `Plane3D` с заданными точкой и нормальным вектором.

#### `test_distance_to_point`:
* **Описание:** Проверяет корректность работы метода `distance_to_point` для вычисления расстояния от точки до плоскости.
* **Тип теста:** Позитивный.
* **Входные данные:** Плоскость, заданная точкой (0, 0, 0) и нормальным вектором (0, 0, 1), точка (1, 2, 3).
* **Ожидаемый результат:** Расстояние от точки до плоскости должно быть равно `3`.

#### `test_is_parallel`:
* **Описание:** Проверяет корректность работы метода `is_parallel` для определения параллельности двух плоскостей.
* **Тип теста:** Позитивный и негативный.
* **Входные данные:** Две параллельные плоскости и две непараллельные плоскости.
* **Ожидаемый результат:** Метод `is_parallel` должен вернуть `True` для параллельных плоскостей и `False` для непараллельных плоскостей.

#### `test_is_perpendicular`:
* **Описание:** Проверяет корректность работы метода `is_perpendicular` для определения перпендикулярности двух плоскостей.
* **Тип теста:** Позитивный и негативный.
* **Входные данные:** Две перпендикулярные плоскости и две неперпендикулярные плоскости.
* **Ожидаемый результат:** Метод `is_perpendicular` должен вернуть `True` для перпендикулярных плоскостей и `False` для неперпендикулярных плоскостей.

#### `test_intersection_with_line`:
* **Описание:** Проверяет корректность работы метода `intersection_with_line` для нахождения точки пересечения прямой и плоскости.
* **Тип теста:** Позитивный и негативный.
* **Входные данные:** Плоскость, и прямая, которая ее пересекает, прямая, которая параллельна плоскости, и прямая, которая лежит на плоскости.
* **Ожидаемый результат:** Метод `intersection_with_line` должен вернуть точку пересечения для пересекающихся прямой и плоскости, `None` для параллельных прямой и плоскости, и `None` для прямой, лежащей на плоскости.

#### `test_point_on_plane`:
* **Описание:** Проверяет корректность работы метода `point_on_plane` для определения, лежит ли точка на плоскости.
* **Тип теста:** Позитивный и негативный.
* **Входные данные:** Плоскость, заданная точкой (1, 2, 3) и нормальным вектором (0, 0, 1), точки (4, 5, 3) и (4, 5, 4).
* **Ожидаемый результат:** Метод `point_on_plane` должен вернуть `True` для точки (4, 5, 3) и `False` для точки (4, 5, 4).

## Интеграционное тестирование

### `test_line2d_with_vector2d`:
* **Описание:** Проверяет взаимодействие класса `Line2D` с классом `Vector2D` путем использования объектов `Vector2D` для определения точек линии и вычисления расстояния от точки до линии.
* **Тип теста:** Позитивный.
* **Входные данные:** Линия, заданная точками `v1 = (1, 2)` и `v2 = (3, 4)`, точки `v3 = (2, 3)` (на линии) и `v4 = (0, 0)` (вне линии).
* **Ожидаемый результат:** Расстояние от точки `v3` до линии должно быть равно 0, расстояние от точки `v4` до линии должно быть больше 0.

### `test_plane3d_with_vector3d`:
* **Описание:** Проверяет взаимодействие класса `Plane3D` с классом `Vector3D` путем использования объектов `Vector3D` для определения точки и нормального вектора плоскости и вычисления расстояния от точки до плоскости.
* **Тип теста:** Позитивный.
* **Входные данные:** Плоскость, заданная точкой `point = (1, 1, 1)` и нормальным вектором `normal = (0, 0, 1)`, точки `point_on_plane = (2, 2, 1)` (на плоскости) и `point_off_plane = (2, 2, 2)` (вне плоскости).
* **Ожидаемый результат:** Расстояние от точки `point_on_plane` до плоскости должно быть равно 0, расстояние от точки `point_off_plane` до плоскости должно быть больше 0.

### `test_line2d_intersection_with_vector2d`:
* **Описание:** Проверяет взаимодействие класса `Line2D` с классом `Vector2D` путем использования объектов `Vector2D` для определения точек линий и нахождения точки пересечения.
* **Тип теста:** Позитивный и негативный.
* **Входные данные:** Две линии: первая проходит через точки (0, 0) и (2, 2), вторая - через точки (0, 2) и (2, 0), а также две параллельные линии.
* **Ожидаемый результат:** Точка пересечения двух первых линий должна быть (1, 1).  Для параллельных линий метод `intersection` должен вернуть `None`.

### `test_plane3d_intersection_with_vector3d_line`:
* **Описание:** Проверяет взаимодействие класса `Plane3D` с классом `Vector3D` путем использования объектов `Vector3D` для определения точек прямой, а также точки и нормального вектора плоскости, и нахождения точки пересечения.
* **Тип теста:** Позитивный.
* **Входные данные:** Плоскость, заданная точкой (0, 0, 0) и нормальным вектором (0, 0, 1), и прямая, заданная точками (0, 0, 10) и (1, 1, -10).
* **Ожидаемый результат:** Точка пересечения должна быть (0.5, 0.5, 0).

### `test_line2d_distance_to_point`:
* **Описание:** Проверяет корректность работы метода `distance_to_point` класса `Line2D` для вычисления расстояния от точки до линии.
* **Тип теста:** Позитивный.
* **Входные данные:** Линия, заданная точками (0, 0) и (1, 1), точка (1, 0).
* **Ожидаемый результат:** Расстояние от точки до линии должно быть равно 0.70710678 (приблизительно).

### `test_line2d_angle_between_lines`:
* **Описание:** Проверяет корректность работы метода `angle` класса `Line2D` для вычисления угла между двумя линиями.
* **Тип теста:** Позитивный.
* **Входные данные:** Две линии: первая проходит через точки (0, 0) и (1, 0), вторая - через точки (0, 0) и (1, 1).
* **Ожидаемый результат:** Угол между линиями должен быть pi/4 (45 градусов).

### `test_point_on_plane3d`:
* **Описание:** Проверяет корректность работы метода `point_on_plane` класса `Plane3D` для случая, когда точка лежит на плоскости и когда точка не лежит на плоскости.
* **Тип теста:** Позитивный и негативный.
* **Входные данные:** Плоскость, заданная точкой (0, 0, 0) и нормальным вектором (0, 0, 1), точки (1, 2, 0) и (1, 2, 1).
* **Ожидаемый результат:** Метод `point_on_plane` должен вернуть `True` для точки (1, 2, 0) и `False` для точки (1, 2, 1).


## Аттестационное тестирование

### `test_3d_intersection`:
* **Описание:** Проверяет корректность работы метода `intersection_with_line` класса `Plane3D` для случая пересечения линии и плоскости в 3D пространстве.
* **Тип теста:** Позитивный.
* **Входные данные:** Плоскость, заданная точкой (0, 0, 0) и нормальным вектором (0, 0, 1), и линия, заданная точками (0, 0, 10) и (1, 1, -10).
* **Ожидаемый результат:** Точка пересечения линии и плоскости должна быть (0.5, 0.5, 0).

### `test_2d_intersection`:
* **Описание:** Проверяет корректность работы метода `intersection` класса `Line2D` для случая пересечения двух линий в 2D пространстве.
* **Тип теста:** Позитивный.
* **Входные данные:** Две линии: первая проходит через точки (0, 0) и (1, 1), вторая - через точки (0, 1) и (1, 0).
* **Ожидаемый результат:** Точка пересечения должна быть (0.5, 0.5).

### `test_parallel_lines`:
* **Описание:** Проверяет корректность работы метода `is_parallel` класса `Line2D` для случая двух параллельных линий в 2D пространстве.
* **Тип теста:** Позитивный.
* **Входные данные:** Две линии: первая проходит через точки (0, 0) и (1, 1), вторая - через точки (1, 1) и (2, 2).
* **Ожидаемый результат:** Метод `is_parallel` должен вернуть `True`.

### `test_perpendicular_planes`:
* **Описание:** Проверяет корректность работы метода `is_perpendicular` класса `Plane3D` для случая двух перпендикулярных плоскостей в 3D пространстве.
* **Тип теста:** Позитивный.
* **Входные данные:** Две плоскости: первая проходит через точку (0, 0, 0) с нормальным вектором (0, 0, 1), вторая проходит через точку (0, 0, 0) с нормальным вектором (1, 0, 0).
* **Ожидаемый результат:** Метод `is_perpendicular` должен вернуть `True`.

### `test_vector3d_operations`:
* **Описание:** Проверяет корректность работы основных операций с трехмерными векторами (сложение, вычитание, умножение на скаляр, длина, нормализация, скалярное произведение, векторное произведение, смешанное произведение).
* **Тип теста:** Позитивный.
* **Входные данные:** Векторы `v1 = (1, 2, 3)`, `v2 = (4, 5, 6)`, скаляр `scalar = 2`.
* **Ожидаемый результат:** Результаты операций должны соответствовать ожидаемым значениям. 

### `test_vector2d_operations`:
* **Описание:** Проверяет корректность работы основных операций с двумерными векторами (сложение, вычитание, умножение на скаляр, длина, нормализация).
* **Тип теста:** Позитивный.
* **Входные данные:** Векторы `v1 = (1, 2)`, `v2 = (3, 4)`, скаляр `scalar = 3`.
* **Ожидаемый результат:** Результаты операций должны соответствовать ожидаемым значениям. 

### `test_line2d_point_on_line`:
* **Описание:** Проверяет корректность работы метода `point_on_line` класса `Line2D` для случая, когда точка лежит на линии, и когда точка не лежит на линии.
* **Тип теста:** Позитивный и негативный.
* **Входные данные:** Линия, заданная точками (0, 0) и (1, 1), точки (0.5, 0.5), (1.5, 1.5) и (1, 0).
* **Ожидаемый результат:** Метод `point_on_line` должен вернуть `True` для точек (0.5, 0.5) и (1.5, 1.5) и `False` для точки (1, 0).

### `test_plane3d_distance`:
* **Описание:** Проверяет корректность работы метода `distance_to_point` класса `Plane3D` для случая вычисления расстояния от точки до плоскости.
* **Тип теста:** Позитивный.
* **Входные данные:** Плоскость, заданная точкой (0, 0, 0) и нормальным вектором (0, 0, 1), точка (1, 2, 3).
* **Ожидаемый результат:** Расстояние от точки до плоскости должно быть равно 3.

### `test_plane3d_parallel_perpendicular`:
* **Описание:** Проверяет корректность работы методов `is_parallel` и `is_perpendicular` класса `Plane3D` для случаев параллельных и перпендикулярных плоскостей.
* **Тип теста:** Позитивный и негативный.
* **Входные данные:** Две параллельные плоскости (с одинаковыми нормальными векторами), две перпендикулярные плоскости, две плоскости, которые не являются ни параллельными, ни перпендикулярными.
* **Ожидаемый результат:** Методы `is_parallel` и `is_perpendicular` должны возвращать соответствующие значения.

### `test_angle_between_lines_and_intersection`:
* **Описание:** Проверяет корректность работы методов `angle` (для вычисления угла между линиями) и `intersection`  (для нахождения точки пересечения) класса `Line2D`.
* **Тип теста:** Позитивный.
* **Входные данные:** Две линии: первая проходит через точки (0, 0) и (1, 0), вторая - через точки (0, 0) и (0, 1).
* **Ожидаемый результат:** Угол между линиями должен быть 90 градусов (pi/2 радиан), точка пересечения должна быть (0, 0).

### `test_point_on_plane_and_distance`:
* **Описание:** Проверяет корректность работы методов `point_on_plane` и `distance_to_point` класса `Plane3D` для случая, когда точка лежит на плоскости и когда точка не лежит на плоскости.
* **Тип теста:** Позитивный и негативный.
* **Входные данные:** Плоскость, заданная точкой (1, 2, 3) и нормальным вектором (0, 0, 1), точки (4, 5, 3) и (4, 5, 4).
* **Ожидаемый результат:** Метод `point_on_plane` должен вернуть `True` для точки (4, 5, 3) и `False` для точки (4, 5, 4), а расстояние от точки до плоскости должно быть 0 для точки (4, 5, 3) и 1 для точки (4, 5, 4).
